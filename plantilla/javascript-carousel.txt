<script>/* <![CDATA[ */ /* Carousel of publications - Blogger */
(function() {
'use strict';

/* === CONFIGURACIÓN GLOBAL === */
const CONFIG = {
  apiPath: '/feeds/posts/default',
  imageSize: 's100-c',
  imageSize2: 's320',
  skeletonItems: 3,
  skeletonItems2: 5,
  poolSize: 12,
  cacheTimeout: 5 * 60 * 1000,
  imageTimeout: 3000,
  retryAttempts: 2
};

const Cache = {
  data: new Map,
  set(key, value) {
    this.data.set(key, { value: value, timestamp: Date.now() });
  },
  get(key) {
    const item = this.data.get(key);
    if (!item) return null;
    if (Date.now() - item.timestamp > CONFIG.cacheTimeout) {
      this.data.delete(key);
      return null;
    }
    return item.value;
  },
  clear() { this.data.clear(); }
};

const CarouselManager = {
  instances: new Map,
  register(element, emblaInstance, type) {
    const id = this.getId(element);
    if (this.instances.has(id)) {
      this.destroy(id);
    }
    this.instances.set(id, {
      element: element,
      embla: emblaInstance,
      type: type,
      observers: new Set()
    });
  },
  destroy(id) {
    const instance = this.instances.get(id);
    if (instance) {
      try {
        if (instance.embla && typeof instance.embla.destroy === "function") {
          instance.embla.destroy();
        }
        instance.observers.forEach(observer => {
          if (observer && typeof observer.disconnect === "function") {
            observer.disconnect();
          }
        });
        instance.element._emblaInstance = null;
      } catch (error) {
        console.warn(`Error destruyendo carrusel ${id}:`, error);
      }
      this.instances.delete(id);
    }
  },
  getId(element) {
    if (!element.dataset.carouselId) {
      element.dataset.carouselId = "carousel_" + Math.random().toString(36).substr(2, 9);
    }
    return element.dataset.carouselId;
  },
  destroyAll() {
    for (const [id] of this.instances) {
      this.destroy(id);
    }
  }
};

/* === FUNCIONES UTILITARIAS === */
function validateImageUrl(url) {
  return new Promise(resolve => {
    if (!url) {
      resolve(false);
      return;
    }
    const img = new Image;
    const timeout = setTimeout(() => {
      img.onload = img.onerror = null;
      resolve(false);
    }, CONFIG.imageTimeout);
    img.onload = () => {
      clearTimeout(timeout);
      resolve(img.naturalWidth >= 100 && img.naturalHeight >= 100);
    };
    img.onerror = () => {
      clearTimeout(timeout);
      resolve(false);
    };
    img.src = url;
  });
}

function hasMedia(entry) {
  const content = entry.content?.$t || "";
  return /(?:youtube\.com|youtu\.be|vimeo\.com|<video|<audio|class=['"]audioPlayer['"]|open\.spotify\.com|soundcloud\.com)/i.test(content);
}

function getPostImage(entry, isCarousel2 = false) {
  const targetSize = isCarousel2 ? CONFIG.imageSize2 : CONFIG.imageSize;
  const content = entry.content?.$t || "";
  const imgMatches = content.match(/<img[^>]+src=["']([^"']+)["'][^>]*>/gi) || [];
  const allImages = [];

  for (const imgTag of imgMatches) {
    const srcMatch = imgTag.match(/src=["']([^"']+)["']/i);
    if (!srcMatch) continue;
    
    const imageUrl = srcMatch[1];
    const widthMatch = imgTag.match(/width=["']?(\d+)["']?/i);
    const heightMatch = imgTag.match(/height=["']?(\d+)["']?/i);
    
    let width = widthMatch ? parseInt(widthMatch[1]) : 0;
    let height = heightMatch ? parseInt(heightMatch[1]) : 0;

    if ((imageUrl.includes("blogspot.com") || imageUrl.includes("googleusercontent.com")) && (!width || !height)) {
      const sizeMatch = imageUrl.match(/\/s(\d+)(?:-c)?/);
      if (sizeMatch) {
        const size = parseInt(sizeMatch[1]);
        width = width || size;
        height = height || size;
      }
    }

    allImages.push({
      url: imageUrl,
      width: width,
      height: height,
      isYouTube: imageUrl.includes("ytimg.com") || imageUrl.includes("youtube.com"),
      isVimeo: imageUrl.includes("vimeo")
    });
  }

  const normalImages = allImages.filter(img => !img.isYouTube && !img.isVimeo);
  const videoImages = allImages.filter(img => img.isYouTube || img.isVimeo);

  if (normalImages.length > 0) {
    const qualityImages = normalImages.filter(img => {
      const isIcon = /icon|favicon|logo/i.test(img.url) || 
                     /\/(16|24|32|48|64)\//.test(img.url) ||
                     img.width > 0 && img.width < 100 ||
                     img.height > 0 && img.height < 100;
      return !isIcon;
    });

    if (qualityImages.length > 0) {
      const scoredImages = qualityImages.map(img => {
        const area = (img.width || 400) * (img.height || 300);
        const aspectRatio = (img.width || 400) / (img.height || 300);
        let sizeScore = 1;
        if (img.width >= 300 && img.width <= 600) sizeScore = 1.5;
        if (img.width >= 400 && img.width <= 500) sizeScore = 2;
        const idealRatios = [16/9, 4/3, 3/2];
        const ratioScore = Math.max(...idealRatios.map(ideal => 1 / (1 + Math.abs(aspectRatio - ideal))));
        return { ...img, score: area * sizeScore * ratioScore };
      });

      scoredImages.sort((a, b) => b.score - a.score);
      const bestImage = scoredImages[0];
      if (bestImage.url.includes("blogspot.com") || bestImage.url.includes("googleusercontent.com")) {
        return bestImage.url.replace(/\/s\d+-c?/, `/${targetSize}`);
      }
      return bestImage.url;
    }
  }

  if (videoImages.length > 0) {
    const videoImage = videoImages[0];
    if (videoImage.isYouTube) {
      const videoId = videoImage.url.match(/\/vi\/([^\/]+)\//)?.[1];
      if (videoId) {
        return `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`;
      }
    }
    return videoImage.url;
  }

  const youtubeId = content.match(/(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/i)?.[1];
  if (youtubeId) {
    return `https://img.youtube.com/vi/${youtubeId}/hqdefault.jpg`;
  }

  const vimeoId = content.match(/player\.vimeo\.com\/video\/(\d+)/i)?.[1];
  if (vimeoId) {
    return `https://vumbnail.com/${vimeoId}_medium.jpg`;
  }

  if (entry.media$thumbnail?.url) {
    let imageUrl = entry.media$thumbnail.url;
    if (imageUrl.includes("ytimg.com")) {
      const videoId = imageUrl.match(/\/vi\/([^\/]+)\//)?.[1];
      if (videoId) {
        return `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`;
      }
    }
    if (imageUrl.includes("blogspot.com") || imageUrl.includes("googleusercontent.com")) {
      const sizeMatch = imageUrl.match(/\/s(\d+)(?:-c)?/);
      if (sizeMatch) {
        const size = parseInt(sizeMatch[1]);
        if (size >= 400) {
          return imageUrl.replace(/\/s\d+-c/, `/${targetSize}`);
        }
      }
    }
    return imageUrl;
  }
  return null;
}

function getPostLabel(entry) {
  const category = entry.category?.[0];
  if (category) {
    return {
      name: category.term,
      url: `${window.location.origin}/search/label/${encodeURIComponent(category.term)}`
    };
  }
  return null;
}

function shuffleArray(array) {
  const result = [...array];
  for (let i = result.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [result[i], result[j]] = [result[j], result[i]];
  }
  return result;
}

function buildApiUrl(label = null, maxResults = 6) {
  const baseUrl = `${window.location.origin}${CONFIG.apiPath}`;
  let url = `${baseUrl}?alt=json&max-results=${maxResults}`;
  if (label?.trim()) {
    url += `&category=${encodeURIComponent(label.trim())}`;
  }
  return url;
}

function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

/* === FUNCIONES DE SKELETON === */
function createSkeleton(type) {
  const skeleton = document.createElement("div");
  const isType2 = type === 2;
  const itemCount = isType2 ? CONFIG.skeletonItems2 : CONFIG.skeletonItems;
  
  skeleton.className = isType2 ? "carousel2-skeleton" : "carousel-skeleton";
  
  for (let i = 0; i < itemCount; i++) {
    const item = document.createElement("div");
    item.className = isType2 ? "skeleton2-item" : "skeletonCarousel-item";
    
    const thumbnailClass = isType2 ? "skeleton2-thumbnail" : "skeletonCarousel-thumbnail";
    const contentClass = isType2 ? "skeleton2-content" : "skeletonCarousel-content";
    const labelClass = isType2 ? "skeleton2-label" : "skeletonCarousel-label";
    const titleClass = isType2 ? "skeleton2-title" : "skeletonCarousel-title";
    
    item.innerHTML = `
      <div class="${thumbnailClass}"></div>
      <div class="${contentClass}">
        <div class="${labelClass}"></div>
        <div class="${titleClass}"></div>
        <div class="${titleClass}"></div>
      </div>
    `;
    skeleton.appendChild(item);
  }
  return skeleton;
}

/* === FUNCIONES GENERADORAS DE HTML === */
function createPostHTML(entry, index, isCarousel2) {
  const imageUrl = getPostImage(entry, isCarousel2);
  const label = getPostLabel(entry);
  const title = entry.title.$t;
  const postUrl = entry.link.find(link => link.rel === "alternate")?.href;
  const hasMediaIcon = hasMedia(entry);

  const prefix = isCarousel2 ? "post2" : "postCarousel";
  const thumbnailHTML = imageUrl 
    ? `<img src="${imageUrl}" alt="${title}" loading="lazy">`
    : `<div class="${prefix}-noImage">Sin Imagen</div>`;

  const playIconHTML = hasMediaIcon 
    ? `<div class="${prefix}-playIcon">
         <svg viewBox="0 0 24 24">
           <path d="M8 5v14l11-7z"/>
         </svg>
       </div>` 
    : "";

  const labelHTML = label 
    ? `<div class="${prefix}-label">
         <a href="${label.url}">${label.name}</a>
       </div>` 
    : "";

  return `
    <div class="${prefix}-item" style="animation-delay: ${index * 0.05}s">
      <div class="${prefix}-thumbnail">
        <a href="${postUrl}">
          ${thumbnailHTML}
          ${playIconHTML}
        </a>
      </div>
      <div class="${prefix}-content">
        ${labelHTML}
        <h3 class="${prefix}-title">
          <a href="${postUrl}">${title}</a>
        </h3>
      </div>
    </div>
  `;
}

function createCarouselHTML(posts, isCarousel2) {
  const slideClass = isCarousel2 ? "carousel2__slide" : "carousel__slide";
  const postsHTML = posts.map((post, index) => 
    `<div class="${slideClass}">${createPostHTML(post, index, isCarousel2)}</div>`
  ).join("");

  const prefix = isCarousel2 ? "carousel2" : "carousel";
  
  return `
    <div class="${prefix}">
      <div class="${prefix}__container">
        ${postsHTML}
      </div>
      <div class="${prefix}__controls">
        <button class="${prefix}__button ${prefix}__button--prev" type="button" aria-label="Anterior">
          <svg viewBox="0 0 24 24">
            <polyline points="15,18 9,12 15,6"></polyline>
          </svg>
        </button>
        <button class="${prefix}__button ${prefix}__button--next" type="button" aria-label="Siguiente">
          <svg viewBox="0 0 24 24">
            <polyline points="9,18 15,12 9,6"></polyline>
          </svg>
        </button>
      </div>
    </div>
  `;
}

/* === FUNCIONES DE INICIALIZACIÓN EMBLA === */
function initEmblaCarousel(container, isCarousel2, autoplay = false) {
  const emblaNode = container.querySelector(isCarousel2 ? ".carousel2" : ".carousel");
  if (!emblaNode) return null;

  const prefix = isCarousel2 ? "carousel2" : "carousel";
  const prevBtn = container.querySelector(`.${prefix}__button--prev`);
  const nextBtn = container.querySelector(`.${prefix}__button--next`);

  const options = {
    align: "start",
    containScroll: "trimSnaps",
    slidesToScroll: 1,
    loop: autoplay,
    skipSnaps: false
  };

  const plugins = [];

  if (isCarousel2 && typeof EmblaCarouselAutoHeight !== "undefined") {
    plugins.push(EmblaCarouselAutoHeight({ destroyHeight: "auto" }));
  }

  if (autoplay && typeof EmblaCarouselAutoplay !== "undefined") {
    plugins.push(EmblaCarouselAutoplay({
      delay: 4000,
      stopOnInteraction: false,
      stopOnMouseEnter: true
    }));
  }

  try {
    const embla = EmblaCarousel(emblaNode, options, plugins);

    const updateButtons = debounce(() => {
      if (prevBtn) prevBtn.disabled = !embla.canScrollPrev();
      if (nextBtn) nextBtn.disabled = !embla.canScrollNext();
    }, 50);

    if (prevBtn) prevBtn.addEventListener("click", () => embla.scrollPrev());
    if (nextBtn) nextBtn.addEventListener("click", () => embla.scrollNext());

    embla.on("select", updateButtons);
    embla.on("init", updateButtons);

    if (isCarousel2) {
      const imageObserver = new IntersectionObserver(entries => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = entry.target;
            if (img.dataset.src) {
              img.src = img.dataset.src;
              img.removeAttribute("data-src");
              imageObserver.unobserve(img);
            }
          }
        });
      }, { rootMargin: "50px" });

      const images = emblaNode.querySelectorAll('img[loading="lazy"]');
      images.forEach(img => {
        if (img.complete) {
          embla.reInit();
        } else {
          img.addEventListener("load", () => embla.reInit(), { once: true });
        }
      });

      const carouselId = CarouselManager.getId(container);
      const instance = CarouselManager.instances.get(carouselId);
      if (instance) {
        instance.observers.add(imageObserver);
      }
    }

    return embla;
  } catch (error) {
    console.error(`Error inicializando ${prefix}:`, error);
    return null;
  }
}

/* === FUNCIONES DE CARGA DE DATOS === */
async function fetchWithRetry(url, attempts = CONFIG.retryAttempts) {
  for (let i = 0; i < attempts; i++) {
    try {
      const response = await fetch(url);
      if (response.ok) return response;
      throw new Error(`HTTP ${response.status}`);
    } catch (error) {
      if (i === attempts - 1) throw error;
      await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
    }
  }
}

async function loadPosts(labels, maxResults, isRandom) {
  const cacheKey = `posts_${labels.join(",")}_${maxResults}_${isRandom}`;
  const cached = Cache.get(cacheKey);
  if (cached) {
    return cached;
  }

  try {
    let allPosts = [];
    
    if (labels?.length > 0) {
      const fetchSize = isRandom ? CONFIG.poolSize : maxResults;
      const promises = labels.map(async label => {
        try {
          const url = buildApiUrl(label, fetchSize);
          const response = await fetchWithRetry(url);
          const data = await response.json();
          return (data.feed?.entry || []).map(post => ({ ...post, _sourceLabel: label }));
        } catch (error) {
          console.warn(`Error cargando etiqueta "${label}":`, error);
          return [];
        }
      });
      const results = await Promise.all(promises);
      allPosts = results.flat();
    } else {
      const fetchSize = isRandom ? CONFIG.poolSize * 2 : maxResults;
      const url = buildApiUrl(null, fetchSize);
      const response = await fetchWithRetry(url);
      const data = await response.json();
      allPosts = data.feed?.entry || [];
    }

    const seen = new Set;
    allPosts = allPosts.filter(post => {
      const url = post.link?.find(link => link.rel === "alternate")?.href;
      if (!url || seen.has(url)) return false;
      seen.add(url);
      return true;
    });

    if (isRandom && allPosts.length > 0) {
      allPosts = shuffleArray(allPosts);
    }

    const finalPosts = allPosts.slice(0, maxResults);
    Cache.set(cacheKey, finalPosts);
    return finalPosts;
  } catch (error) {
    console.warn("Error cargando posts:", error);
    return [];
  }
}

/* === FUNCIÓN PRINCIPAL DE INICIALIZACIÓN === */
async function initCarousel(element) {
  element.classList.add("carousel-loading");

  try {
    const isCarousel2 = element.classList.contains("carousel-2");
    const labelAttr = element.getAttribute("data-label") || "";
    const maxResults = Math.min(parseInt(element.getAttribute("data-max")) || 6, 20);
    const isRandom = element.getAttribute("data-random") === "true";
    const autoplay = element.getAttribute("data-autoplay") === "true";
    const labels = labelAttr ? labelAttr.split(",").map(l => l.trim()).filter(Boolean) : [];

    const skeleton = createSkeleton(isCarousel2 ? 2 : 1);
    element.appendChild(skeleton);

    const posts = await loadPosts(labels, maxResults, isRandom);

    if (skeleton.parentNode) {
      skeleton.parentNode.removeChild(skeleton);
    }

    if (posts.length === 0) {
      const noPostsClass = isCarousel2 ? "carousel2-noPosts" : "carousel-noPosts";
      element.innerHTML = `<div class="${noPostsClass}">No se encontraron publicaciones.</div>`;
      return;
    }

    element.innerHTML = createCarouselHTML(posts, isCarousel2);

    if (isCarousel2) {
      await new Promise(resolve => setTimeout(resolve, 50));
    }

    const embla = initEmblaCarousel(element, isCarousel2, autoplay);
    if (embla) {
      const carouselType = isCarousel2 ? "carousel-2" : "carousel-1";
      CarouselManager.register(element, embla, carouselType);
      element._emblaInstance = embla;
    }
  } catch (error) {
    console.error("Error inicializando carrusel:", error);
    const noPostsClass = element.classList.contains("carousel-2") ? "carousel2-noPosts" : "carousel-noPosts";
    element.innerHTML = `<div class="carousel-error">Error al cargar el carrusel. <button onclick="window.BloggerCarousel.init(this.closest('.carousel-1, .carousel-2'))">Reintentar</button></div>`;
  } finally {
    element.classList.remove("carousel-loading");
  }
}

function initAllCarousels() {
  const carousels1 = document.querySelectorAll(".carousel-1:not([data-initialized])");
  const carousels2 = document.querySelectorAll(".carousel-2:not([data-initialized])");
  
  [...carousels1, ...carousels2].forEach(carousel => {
    carousel.setAttribute("data-initialized", "true");
    initCarousel(carousel);
  });
}

/* === EVENT LISTENERS === */
window.addEventListener("beforeunload", () => {
  CarouselManager.destroyAll();
  Cache.clear();
});

let currentUrl = window.location.href;
const urlObserver = new MutationObserver(() => {
  if (window.location.href !== currentUrl) {
    currentUrl = window.location.href;
    CarouselManager.destroyAll();
    setTimeout(initAllCarousels, 500);
  }
});
urlObserver.observe(document.body, { childList: true, subtree: true });

if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", initAllCarousels);
} else {
  setTimeout(initAllCarousels, 100);
}

/* === API PÚBLICA === */
window.BloggerCarousel = {
  init: initCarousel,
  initAll: initAllCarousels,
  cache: Cache,
  manager: CarouselManager,
  config: CONFIG
};

})();
 /* ]]> */ </script>